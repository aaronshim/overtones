module CollectionTest exposing (..)

import Test exposing (..)
import Expect
import Fuzz exposing (list, int, intRange, string, maybe, Fuzzer, tuple, map3)
import Fuzzer exposing (..)
import Collection exposing (..)
import Dict


collectionTests : Test
collectionTests =
    describe "Collection module"
        [ describe "Multiple inserts on collection"
            [ fuzz2 (collection int) (list int) "Correct size after multiple inserts" <|
                \initialCollection xs ->
                    let
                        collectionAfterInsert =
                            List.foldl (\x accm -> insert x accm) initialCollection xs

                        initialCollectionSize =
                            Dict.size <| toDict initialCollection

                        finalCollectionSize =
                            Dict.size <| toDict collectionAfterInsert
                    in
                        Expect.equal (initialCollectionSize + List.length xs) finalCollectionSize

            {- The initial collection must contain a mutually exclusive subset of the same type as the inserted elements to
               make sure that the presence test doesn't test a preexisting element generated by a particularly lucky fuzzing.
            -}
            , fuzz2 (collection allUppercaseString) (notEmptyList "a" allLowercaseString) "Correct inclusion after multiple inserts" <|
                \initialCollection xs ->
                    let
                        collectionAfterInsert =
                            List.foldl (\x accm -> insert x accm) initialCollection xs
                    in
                        Expect.all (List.map (\x collection -> Expect.true "The collection contains the item" <| contains x collection) xs) <| collectionAfterInsert
            ]
        , describe "Multiple inserts with RemoveLast"
            [ fuzz (list (maybe int)) "Correct size after multiple inserts and removeLast" <|
                \xs ->
                    let
                        collectionAfterInsert =
                            List.foldl (\f accm -> (translateToInsertsAndRemoveLast f) accm) (emptyCollectionWithContext NoContext) xs
                    in
                        Expect.atMost (numInsertsForInsertsAndRemoveLast xs) (Dict.size <| toDict collectionAfterInsert)
            , fuzz (list (maybe int)) "Correct next index after multiple inserts and removeLast" <|
                \xs ->
                    let
                        collectionAfterInsert =
                            List.foldl (\f accm -> (translateToInsertsAndRemoveLast f) accm) (emptyCollectionWithContext NoContext) xs
                    in
                        -- nextIndex should not be present in the dict currently
                        Expect.equal Nothing (Dict.get collectionAfterInsert.nextIndex (toDict collectionAfterInsert))
            ]
        , describe "Multiple inserts with Remove (index) and RemoveLast"
            {- we are going to use a tuple fuzzer here because we need things in the shape [(a, Maybe Int)] because there should be
               as many of the a as there are Maybe Int's since two of them combined together form a correct input to the fuzzing test.
               (a is what gets inserted and Maybe Int is an index to remove or a Nothing to signify an insert)
               (to clean it up, I guess we can write our own fuzzer? It's harder for this one that has a dependence on the current
               state of the collection to make a valid command, though...)
            -}
            [ fuzz (list (tuple ( int, maybe int ))) "Correct size after multiple inserts and removeLast and remove (by index)" <|
                \xs ->
                    let
                        collectionAfterInsert =
                            List.foldl (\( toInsert, f ) accm -> (translateToInsertsAndRemoveIndex accm toInsert f) accm)
                                (emptyCollectionWithContext NoContext)
                                xs
                    in
                        Expect.atMost (numInsertsForInsertsAndRemoveIndex xs) (Dict.size <| toDict collectionAfterInsert)
            , fuzz (list (tuple ( int, maybe int ))) "Correct next index after multiple inserts and removeLast and remove (by index)" <|
                \xs ->
                    let
                        collectionAfterInsert =
                            List.foldl (\( toInsert, f ) accm -> (translateToInsertsAndRemoveIndex accm toInsert f) accm)
                                (emptyCollectionWithContext NoContext)
                                xs
                    in
                        -- nextIndex should not be present in the dict currently
                        Expect.equal Nothing (Dict.get collectionAfterInsert.nextIndex (toDict collectionAfterInsert))
            ]
        ]
