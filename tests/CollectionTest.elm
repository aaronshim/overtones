module CollectionTest exposing (..)

import Test exposing (..)
import Expect
import Fuzz exposing (char, list, int, intRange, string, maybe, Fuzzer, conditional, tuple, map, map3)
import Char
import Dict
import Collection exposing (..)


-- Custom Fuzzers


allUppercaseString : Fuzzer String
allUppercaseString =
    allCaseString 'A' Char.isUpper


allLowercaseString : Fuzzer String
allLowercaseString =
    allCaseString 'a' Char.isLower



{- These fuzzers are to generate two subsets of strings that are mutually exclusive -}


allCaseString : Char -> (Char -> Bool) -> Fuzzer String
allCaseString defaultRightCaseChar isRightCase =
    conditional
        { retries = 10
        , fallback = (\xs -> String.fromList [ defaultRightCaseChar ])
        , condition = (\xs -> String.length xs > 0)
        }
        (map (String.filter isRightCase << String.fromList) <| notEmptyList defaultRightCaseChar char)


notEmptyList : a -> Fuzzer a -> Fuzzer (List a)
notEmptyList defaultValue fuzzer =
    conditional
        { retries = 10
        , fallback = (\xs -> defaultValue :: xs)
        , condition = (\xs -> List.length xs > 0)
        }
        (list fuzzer)


collection : Fuzzer a -> Fuzzer (Collection a)
collection fuzzerA =
    collectionWithContext fuzzerA (Fuzz.constant NoContext)


collectionWithContext : Fuzzer a -> Fuzzer b -> Fuzzer (CollectionWithContext a b)
collectionWithContext fuzzerA fuzzerB =
    let
        fuzzerElemsToInsert =
            list fuzzerA

        -- or maybe some better way to get indices that are likely?
        fuzzerRemoveIndices =
            list <| intRange 0 10

        insertCollection elemsToInsert context =
            List.foldl (\elem accm -> insert elem accm) (emptyCollectionWithContext context) elemsToInsert

        makeCollection elemsToInsert context removeIndices =
            List.foldl (\i accm -> (translateRemoveIndex accm i) accm) (insertCollection elemsToInsert context) removeIndices
    in
        map3 makeCollection fuzzerElemsToInsert fuzzerB fuzzerRemoveIndices



-- Dealing with fuzzing a stream of manipulations on the Collection


type alias CollectionModificationFunction a b =
    CollectionWithContext a b -> CollectionWithContext a b


translateToInsertsAndRemoveLast : Maybe a -> CollectionModificationFunction a b
translateToInsertsAndRemoveLast n =
    case n of
        Just n_ ->
            insert n_

        Nothing ->
            removeLastInserted


translateToInsertsAndRemoveIndex : CollectionWithContext a b -> a -> Maybe Int -> CollectionModificationFunction a b
translateToInsertsAndRemoveIndex collectionSoFar elemToInsert index =
    case index of
        Just index_ ->
            translateRemoveIndex collectionSoFar index_

        Nothing ->
            insert elemToInsert


translateRemoveIndex : CollectionWithContext a b -> Int -> CollectionModificationFunction a b
translateRemoveIndex collectionSoFar index =
    if isValidIndex index collectionSoFar then
        remove index
    else
        removeLastInserted


isJust : Maybe a -> Bool
isJust x =
    case x of
        Just _ ->
            True

        Nothing ->
            False


numInsertsForInsertsAndRemoveLast : List (Maybe a) -> Int
numInsertsForInsertsAndRemoveLast =
    List.length << List.filter isJust


numInsertsForInsertsAndRemoveIndex : List ( a, Maybe Int ) -> Int
numInsertsForInsertsAndRemoveIndex =
    List.length << List.filter (\( _, indexToRemove ) -> not <| isJust indexToRemove)



-- For dealing with our custom Collection type


contains : a -> CollectionWithContext a b -> Bool
contains x collection =
    toDict collection |> Dict.values |> List.member x


isValidIndex : Int -> CollectionWithContext a b -> Bool
isValidIndex i collection =
    toDict collection |> Dict.keys |> List.member i


collectionTests : Test
collectionTests =
    describe "Collection module"
        [ describe "Multiple inserts on collection"
            [ fuzz2 (collection int) (list int) "Correct size after multiple inserts" <|
                \initialCollection xs ->
                    let
                        collectionAfterInsert =
                            List.foldl (\x accm -> insert x accm) initialCollection xs

                        initialCollectionSize =
                            Dict.size <| toDict initialCollection

                        finalCollectionSize =
                            Dict.size <| toDict collectionAfterInsert
                    in
                        Expect.equal (initialCollectionSize + List.length xs) finalCollectionSize

            {- The initial collection must contain a mutually exclusive subset of the same type as the inserted elements to
               make sure that the presence test doesn't test a preexisting element generated by a particularly lucky fuzzing.
            -}
            , fuzz2 (collection allUppercaseString) (notEmptyList "a" allLowercaseString) "Correct inclusion after multiple inserts" <|
                \initialCollection xs ->
                    let
                        collectionAfterInsert =
                            List.foldl (\x accm -> insert x accm) initialCollection xs
                    in
                        Expect.all (List.map (\x collection -> Expect.true "The collection contains the item" <| contains x collection) xs) <| collectionAfterInsert
            ]
        , describe "Multiple inserts with RemoveLast"
            [ fuzz (list (maybe int)) "Correct size after multiple inserts and removeLast" <|
                \xs ->
                    let
                        collectionAfterInsert =
                            List.foldl (\f accm -> (translateToInsertsAndRemoveLast f) accm) (emptyCollectionWithContext NoContext) xs
                    in
                        Expect.atMost (numInsertsForInsertsAndRemoveLast xs) (Dict.size <| toDict collectionAfterInsert)
            , fuzz (list (maybe int)) "Correct next index after multiple inserts and removeLast" <|
                \xs ->
                    let
                        collectionAfterInsert =
                            List.foldl (\f accm -> (translateToInsertsAndRemoveLast f) accm) (emptyCollectionWithContext NoContext) xs
                    in
                        -- nextIndex should not be present in the dict currently
                        Expect.equal Nothing (Dict.get collectionAfterInsert.nextIndex (toDict collectionAfterInsert))
            ]
        , describe "Multiple inserts with Remove (index) and RemoveLast"
            {- we are going to use a tuple fuzzer here because we need things in the shape [(a, Maybe Int)] because there should be
               as many of the a as there are Maybe Int's since two of them combined together form a correct input to the fuzzing test.
               (a is what gets inserted and Maybe Int is an index to remove or a Nothing to signify an insert)
               (to clean it up, I guess we can write our own fuzzer? It's harder for this one that has a dependence on the current
               state of the collection to make a valid command, though...)
            -}
            [ fuzz (list (tuple ( int, maybe int ))) "Correct size after multiple inserts and removeLast and remove (by index)" <|
                \xs ->
                    let
                        collectionAfterInsert =
                            List.foldl (\( toInsert, f ) accm -> (translateToInsertsAndRemoveIndex accm toInsert f) accm)
                                (emptyCollectionWithContext NoContext)
                                xs
                    in
                        Expect.atMost (numInsertsForInsertsAndRemoveIndex xs) (Dict.size <| toDict collectionAfterInsert)
            , fuzz (list (tuple ( int, maybe int ))) "Correct next index after multiple inserts and removeLast and remove (by index)" <|
                \xs ->
                    let
                        collectionAfterInsert =
                            List.foldl (\( toInsert, f ) accm -> (translateToInsertsAndRemoveIndex accm toInsert f) accm)
                                (emptyCollectionWithContext NoContext)
                                xs
                    in
                        -- nextIndex should not be present in the dict currently
                        Expect.equal Nothing (Dict.get collectionAfterInsert.nextIndex (toDict collectionAfterInsert))
            ]
        ]
